{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///tasktimer.min.js","webpack:///webpack/bootstrap 00c84dd4c994f31aba94","webpack:///./src/index.js","webpack:///./src/tasktimer.js","webpack:///./~/eventemitter3/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_tasktimer","_tasktimer2","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_defaults","object","defaults","key","hasOwnProperty","undefined","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_get","get","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_eventemitter","_eventemitter2","DEFAULT","INTERVAL","TaskTimer","_EventEmitter","interval","arguments","_this","_","_reset","timer","clearInterval","_stop","state","State","IDLE","tasks","tickCount","startTime","stopTime","name","task","emit","Event","TICK","tickInterval","totalRuns","currentRuns","callback","TASK","_this2","setInterval","_tick","RUNNING","eventName","event","type","source","TASK_ADDED","TASK_REMOVED","options","Error","getTask","removedTask","Date","now","_run","STARTED","PAUSED","RESUMED","STOPPED","RESET","listeners","set","current","freeze","started","stopped","elapsed","keys","EE","fn","context","once","EventEmitter","has","prefix","_events","eventNames","events","names","push","slice","getOwnPropertySymbols","concat","exists","evt","available","l","ee","Array","a1","a2","a3","a4","a5","args","len","removeListener","apply","j","on","listener","removeAllListeners","off","addListener","setMaxListeners","prefixed"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,eAAAH,GACA,gBAAAC,SACAA,QAAA,UAAAD,IAEAD,EAAA,UAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,QAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAE/B,YAMA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GE9DxF,GAAAG,GAAAb,EAAA,GF4DKc,EAAcL,EAAuBI,EEzD1ClB,GAAOD,QAAPoB,cFmEM,SAASnB,EAAQD,EAASM,GAE/B,YAcA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAEvF,QAASK,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMf,GAAQ,IAAKe,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOhB,GAAyB,gBAATA,IAAqC,kBAATA,GAA8Be,EAAPf,EAElO,QAASiB,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GGidle,QAASW,GAAUC,EAAQC,GACvB,IAAKD,EAAQ,MAAOC,MACpB,KAAKA,EAAU,MAAOD,MACtB,IAAIE,EACJ,KAAKA,IAAOD,GACJA,EAASE,eAAeD,IACDE,SAAhBJ,EAAOE,KACdF,EAAOE,GAAOD,EAASC,GAG/B,OAAOF,GH7eVV,OAAOe,eAAe/C,EAAS,cAC3BmC,OAAO,GAGX,IAAIa,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWlB,WAAakB,EAAWlB,aAAc,EAAOkB,EAAWhB,cAAe,EAAU,SAAWgB,KAAYA,EAAWjB,UAAW,GAAML,OAAOe,eAAeG,EAAQI,EAAWV,IAAKU,IAAiB,MAAO,UAAU/B,EAAagC,EAAYC,GAAiJ,MAA9HD,IAAYN,EAAiB1B,EAAYQ,UAAWwB,GAAiBC,GAAaP,EAAiB1B,EAAaiC,GAAqBjC,MAE5hBkC,EAAO,QAASC,GAAIhB,EAAQiB,EAAUC,GAA2B,OAAXlB,IAAiBA,EAASmB,SAAS9B,UAAW,IAAI+B,GAAO9B,OAAO+B,yBAAyBrB,EAAQiB,EAAW,IAAab,SAATgB,EAAoB,CAAE,GAAIE,GAAShC,OAAOiC,eAAevB,EAAS,OAAe,QAAXsB,EAAmB,OAAkCN,EAAIM,EAAQL,EAAUC,GAAoB,GAAI,SAAWE,GAAQ,MAAOA,GAAK3B,KAAgB,IAAI+B,GAASJ,EAAKJ,GAAK,IAAeZ,SAAXoB,EAA4C,MAAOA,GAAOvD,KAAKiD,IGhF7dO,EAAA7D,EAAA,GHoFK8D,EAAiBrD,EAAuBoD,GGlFvCE,GACFC,SAAU,KAoBRC,EH6FW,SAAUC,GG1DvB,QAAAD,KAAyC,GAA7BE,GAA6BC,UAAArB,QAAA,GAAAP,SAAA4B,UAAA,GAAlBL,EAAQC,SAAUI,UAAA,EAAArD,GAAAjB,KAAAmE,EAAA,IAAAI,GAAAlD,EAAArB,KAAA4B,OAAAiC,eAAAM,GAAA5D,KAAAP,MAAA,OAErCuE,GAAKC,KACLD,EAAKE,SACLF,EAAKC,EAAEH,SAAWA,EAJmBE,EH6iBxC,MAlfA/C,GAAU2C,EAAWC,GA6DrBxB,EAAauB,IACT3B,IAAK,QAWLT,MAAO,WG3CJ/B,KAAKwE,EAAEE,QACPC,cAAc3E,KAAKwE,EAAEE,OACrB1E,KAAKwE,EAAEE,MAAQ,SHsDlBlC,IAAK,SACLT,MAAO,WG9CR/B,KAAK4E,OACL,IAAIP,GAAWrE,KAAKwE,EAAEH,QACtBrE,MAAKwE,GACDH,SAAUA,EACVK,MAAO,KACPG,MAAOV,EAAUW,MAAMC,KACvBC,SACAC,UAAW,EACXC,UAAW,EACXC,SAAU,MHyDb3C,IAAK,QACLT,MAAO,WGjDR,GAAIqD,GAAA,OAAMC,EAAA,OACNL,EAAQhF,KAAKwE,EAAEQ,KAEnBhF,MAAKwE,EAAES,WAAa,EACpBjF,KAAKsF,KAAKnB,EAAUoB,MAAMC,KAE1B,KAAKJ,IAAQpF,MAAKwE,EAAEQ,MACZA,EAAMI,KACNC,EAAOL,EAAMI,GACTpF,KAAKwE,EAAES,UAAYI,EAAKI,eAAiB,KACpCJ,EAAKK,WAAaL,EAAKM,YAAcN,EAAKK,aAC3CL,EAAKM,aAAe,EACS,kBAAlBN,GAAKO,UACZP,EAAKO,SAASP,GAElBrF,KAAKsF,KAAKnB,EAAUoB,MAAMM,KAAMR,QHgE/C7C,IAAK,OACLT,MAAO,WGtDL,GAAA+D,GAAA9F,IACHA,MAAKwE,EAAEE,MAAQqB,YAAY,WAEvBD,EAAKE,QACLF,EAAKtB,EAAEK,MAAQV,EAAUW,MAAMmB,SAChCjG,KAAKwE,EAAEH,aH6ET7B,IAAK,OACLT,MAAO,SG3DPmE,EAAW5D,GACZ,GAAI6D,IACAC,KAAMF,EACNG,OAAQrG,KAEZ,QAAQkG,GACJ,IAAK/B,GAAUoB,MAAMM,KACrB,IAAK1B,GAAUoB,MAAMe,WACrB,IAAKnC,GAAUoB,MAAMgB,aACjBJ,EAAMd,KAAO/C,EAMrB,MADAe,GAAAzB,OAAAiC,eAAAM,EAAAxC,WAAA,OAAA3B,MAAAO,KAAAP,KAAWkG,EAAWC,GACfnG,QHmENwC,IAAK,OACLT,MAAO,SG9DPmE,EAAW5D,GACZ,MAAOtC,MAAKsF,KAAKY,EAAW5D,MH2E3BE,IAAK,UACLT,MAAO,SGjEJqD,GACJ,MAAOpF,MAAKwE,EAAEQ,MAAMI,MHgGnB5C,IAAK,UACLT,MAAO,WGpEyC,GAA7CyE,GAA6ClC,UAAArB,QAAA,GAAAP,SAAA4B,UAAA,IAAjCmB,aAAc,EAAGC,UAAW,GAAKpB,UAAA,EAQjD,IAPuB,gBAAZkC,KACPA,GACIpB,KAAMoB,EACNf,aAAc,EACdC,UAAW,KAGdc,EAAQpB,KACT,KAAM,IAAIqB,OAAM,yBAEpB,IAAIzG,KAAKwE,EAAEQ,MAAMwB,EAAQpB,MACrB,KAAM,IAAIqB,OAAM,mBAAqBD,EAAQpB,KAAO,oBAExD,IAAIC,GAAOhD,EAAUmE,GACjBb,YAAa,GAIjB,OAFA3F,MAAKwE,EAAEQ,MAAMwB,EAAQpB,MAAQC,EAC7BrF,KAAKsF,KAAKnB,EAAUoB,MAAMe,WAAYtG,KAAK0G,QAAQF,EAAQpB,OACpDpF,QHuFNwC,IAAK,YACLT,MAAO,SGzEFqD,GACN,IAAKA,IAASpF,KAAKwE,EAAEQ,MAAMI,GACvB,KAAM,IAAIqB,OAAM,mBAAqBrB,EAAO,oBAEhDpF,MAAKwE,EAAEQ,MAAMI,GAAMO,YAAc,KHyFhCnD,IAAK,aACLT,MAAO,SG5EDqD,GACP,IAAKA,IAASpF,KAAKwE,EAAEQ,MAAMI,GACvB,KAAM,IAAIqB,OAAM,mBAAqBrB,EAAO,oBAEhD,IAAIuB,GAAc3G,KAAKwE,EAAEQ,MAAMI,EAI/B,OAHApF,MAAKwE,EAAEQ,MAAMI,GAAQ,WACdpF,MAAKwE,EAAEQ,MAAMI,GACpBpF,KAAKsF,KAAKnB,EAAUoB,MAAMgB,aAAcI,GACjC3G,QH0FNwC,IAAK,QACLT,MAAO,WGvER,MAPA/B,MAAK4E,QACL5E,KAAKwE,EAAEU,UAAY0B,KAAKC,MACxB7G,KAAKwE,EAAEW,SAAW,EAClBnF,KAAKwE,EAAES,UAAY,EACnBjF,KAAK8G,OACL9G,KAAKwE,EAAEK,MAAQV,EAAUW,MAAMmB,QAC/BjG,KAAKsF,KAAKnB,EAAUoB,MAAMwB,SACnB/G,QH2FNwC,IAAK,QACLT,MAAO,WGjFR,MAAI/B,MAAK6E,QAAUV,EAAUW,MAAMmB,QAAgBjG,MACnDA,KAAK4E,QACL5E,KAAKwE,EAAEK,MAAQV,EAAUW,MAAMkC,OAC/BhH,KAAKsF,KAAKnB,EAAUoB,MAAMyB,QACnBhH,SH+FNwC,IAAK,SACLT,MAAO,WGpFR,MAAI/B,MAAK6E,QAAUV,EAAUW,MAAMkC,OAAehH,MAClDA,KAAK8G,OACL9G,KAAKwE,EAAEK,MAAQV,EAAUW,MAAMmB,QAC/BjG,KAAKsF,KAAKnB,EAAUoB,MAAM0B,SACnBjH,SHmGNwC,IAAK,OACLT,MAAO,WGvFR,MAAI/B,MAAK6E,QAAUV,EAAUW,MAAMmB,QAAgBjG,MACnDA,KAAK4E,QACL5E,KAAKwE,EAAEW,SAAWyB,KAAKC,MACvB7G,KAAKwE,EAAEK,MAAQV,EAAUW,MAAMoC,QAC/BlH,KAAKsF,KAAKnB,EAAUoB,MAAM2B,SACnBlH,SHsGNwC,IAAK,QACLT,MAAO,WGxFR,MAFA/B,MAAKyE,SACLzE,KAAKsF,KAAKnB,EAAUoB,MAAM4B,OACnBnH,QHqGNwC,IAAK,gBACLT,MAAO,SG9FEmE,GACV,MAAOlG,MAAKoH,UAAUlB,GAAWjD,UHiGhCT,IAAK,WACLc,IAAK,WG/cN,MAAOtD,MAAKwE,EAAEH,UHkdbgD,IAAK,SGhdGtF,GACT/B,KAAKwE,EAAEH,SAAWtC,GAASkC,EAAQC,YH6dlC1B,IAAK,QACLc,IAAK,WGldN,MAAOtD,MAAKwE,EAAEK,SHkebrC,IAAK,OACLc,IAAK,WGrdN,GAAIgE,GAAUtH,KAAK6E,QAAUV,EAAUW,MAAMoC,QAAUN,KAAKC,MAAQ7G,KAAKwE,EAAEW,QAC3E,OAAOvD,QAAO2F,QACVC,QAASxH,KAAKwE,EAAEU,UAChBuC,QAASzH,KAAKwE,EAAEW,SAChBuC,QAASJ,EAAUtH,KAAKwE,EAAEU,eHoe7B1C,IAAK,YACLc,IAAK,WGxdN,MAAOtD,MAAKwE,EAAES,aHsebzC,IAAK,YACLc,IAAK,WG3dN,MAAO1B,QAAO+F,KAAK3H,KAAKwE,EAAEQ,OAAO/B,WHge7BkB,GACTH,aGhKHG,GAAUoB,MAAQ3D,OAAO2F,QAMrB/B,KAAM,OAONuB,QAAS,UAOTE,QAAS,UAMTD,OAAQ,SAMRE,QAAS,UAMTC,MAAO,QAMPtB,KAAM,OAMNS,WAAY,YAQZC,aAAc,gBAQlBpC,EAAUW,MAAQlD,OAAO2F,QAQrBxC,KAAM,EAONkB,QAAS,EAMTe,OAAQ,EAMRE,QAAS,IHqMZtH,aG5KcuE,GH2OT,SAAStE,EAAQD,EAASM,GIzyBhC,YAsBA,SAAA0H,GAAAC,EAAAC,EAAAC,GACA/H,KAAA6H,KACA7H,KAAA8H,UACA9H,KAAA+H,SAAA,EAUA,QAAAC,MAjCA,GAAAC,GAAArG,OAAAD,UAAAc,eAUAyF,EAAA,kBAAAtG,QAAAC,QAAA,GA+BAmG,GAAArG,UAAAwG,QAAAzF,OASAsF,EAAArG,UAAAyG,WAAA,WACA,GAEAhD,GAFAiD,EAAArI,KAAAmI,QACAG,IAGA,KAAAD,EAAA,MAAAC,EAEA,KAAAlD,IAAAiD,GACAJ,EAAA1H,KAAA8H,EAAAjD,IAAAkD,EAAAC,KAAAL,EAAA9C,EAAAoD,MAAA,GAAApD,EAGA,OAAAxD,QAAA6G,sBACAH,EAAAI,OAAA9G,OAAA6G,sBAAAJ,IAGAC,GAWAN,EAAArG,UAAAyF,UAAA,SAAAjB,EAAAwC,GACA,GAAAC,GAAAV,IAAA/B,IACA0C,EAAA7I,KAAAmI,SAAAnI,KAAAmI,QAAAS,EAEA,IAAAD,EAAA,QAAAE,CACA,KAAAA,EAAA,QACA,IAAAA,EAAAhB,GAAA,OAAAgB,EAAAhB,GAEA,QAAA7E,GAAA,EAAA8F,EAAAD,EAAA5F,OAAA8F,EAAA,GAAAC,OAAAF,GAA0D9F,EAAA8F,EAAO9F,IACjE+F,EAAA/F,GAAA6F,EAAA7F,GAAA6E,EAGA,OAAAkB,IAUAf,EAAArG,UAAA2D,KAAA,SAAAa,EAAA8C,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAT,GAAAV,IAAA/B,GAEA,KAAAnG,KAAAmI,UAAAnI,KAAAmI,QAAAS,GAAA,QAEA,IAEAU,GACAtG,EAHAoE,EAAApH,KAAAmI,QAAAS,GACAW,EAAAjF,UAAArB,MAIA,sBAAAmE,GAAAS,GAAA,CAGA,OAFAT,EAAAW,MAAA/H,KAAAwJ,eAAArD,EAAAiB,EAAAS,GAAAnF,QAAA,GAEA6G,GACA,aAAAnC,GAAAS,GAAAtH,KAAA6G,EAAAU,UAAA,CACA,cAAAV,GAAAS,GAAAtH,KAAA6G,EAAAU,QAAAmB,IAAA,CACA,cAAA7B,GAAAS,GAAAtH,KAAA6G,EAAAU,QAAAmB,EAAAC,IAAA,CACA,cAAA9B,GAAAS,GAAAtH,KAAA6G,EAAAU,QAAAmB,EAAAC,EAAAC,IAAA,CACA,cAAA/B,GAAAS,GAAAtH,KAAA6G,EAAAU,QAAAmB,EAAAC,EAAAC,EAAAC,IAAA,CACA,cAAAhC,GAAAS,GAAAtH,KAAA6G,EAAAU,QAAAmB,EAAAC,EAAAC,EAAAC,EAAAC,IAAA,EAGA,IAAArG,EAAA,EAAAsG,EAAA,GAAAN,OAAAO,EAAA,GAAyCvG,EAAAuG,EAASvG,IAClDsG,EAAAtG,EAAA,GAAAsB,UAAAtB,EAGAoE,GAAAS,GAAA4B,MAAArC,EAAAU,QAAAwB,OACG,CACH,GACAI,GADAzG,EAAAmE,EAAAnE,MAGA,KAAAD,EAAA,EAAeA,EAAAC,EAAYD,IAG3B,OAFAoE,EAAApE,GAAA+E,MAAA/H,KAAAwJ,eAAArD,EAAAiB,EAAApE,GAAA6E,GAAAnF,QAAA,GAEA6G,GACA,OAAAnC,EAAApE,GAAA6E,GAAAtH,KAAA6G,EAAApE,GAAA8E,QAA2D,MAC3D,QAAAV,EAAApE,GAAA6E,GAAAtH,KAAA6G,EAAApE,GAAA8E,QAAAmB,EAA+D,MAC/D,QAAA7B,EAAApE,GAAA6E,GAAAtH,KAAA6G,EAAApE,GAAA8E,QAAAmB,EAAAC,EAAmE,MACnE,SACA,IAAAI,EAAA,IAAAI,EAAA,EAAAJ,EAAA,GAAAN,OAAAO,EAAA,GAA0DG,EAAAH,EAASG,IACnEJ,EAAAI,EAAA,GAAApF,UAAAoF,EAGAtC,GAAApE,GAAA6E,GAAA4B,MAAArC,EAAApE,GAAA8E,QAAAwB,IAKA,UAWAtB,EAAArG,UAAAgI,GAAA,SAAAxD,EAAA0B,EAAAC,GACA,GAAA8B,GAAA,GAAAhC,GAAAC,EAAAC,GAAA9H,MACA4I,EAAAV,IAAA/B,GAWA,OATAnG,MAAAmI,UAAAnI,KAAAmI,QAAAD,KAA+CtG,OAAAC,OAAA,OAC/C7B,KAAAmI,QAAAS,GAEA5I,KAAAmI,QAAAS,GAAAf,GACA7H,KAAAmI,QAAAS,IACA5I,KAAAmI,QAAAS,GAAAgB,GAFA5J,KAAAmI,QAAAS,GAAAL,KAAAqB,GAFA5J,KAAAmI,QAAAS,GAAAgB,EAQA5J,MAWAgI,EAAArG,UAAAoG,KAAA,SAAA5B,EAAA0B,EAAAC,GACA,GAAA8B,GAAA,GAAAhC,GAAAC,EAAAC,GAAA9H,OAAA,IACA4I,EAAAV,IAAA/B,GAWA,OATAnG,MAAAmI,UAAAnI,KAAAmI,QAAAD,KAA+CtG,OAAAC,OAAA,OAC/C7B,KAAAmI,QAAAS,GAEA5I,KAAAmI,QAAAS,GAAAf,GACA7H,KAAAmI,QAAAS,IACA5I,KAAAmI,QAAAS,GAAAgB,GAFA5J,KAAAmI,QAAAS,GAAAL,KAAAqB,GAFA5J,KAAAmI,QAAAS,GAAAgB,EAQA5J,MAYAgI,EAAArG,UAAA6H,eAAA,SAAArD,EAAA0B,EAAAC,EAAAC,GACA,GAAAa,GAAAV,IAAA/B,GAEA,KAAAnG,KAAAmI,UAAAnI,KAAAmI,QAAAS,GAAA,MAAA5I,KAEA,IAAAoH,GAAApH,KAAAmI,QAAAS,GACAP,IAEA,IAAAR,EACA,GAAAT,EAAAS,IAEAT,EAAAS,QACAE,IAAAX,EAAAW,MACAD,GAAAV,EAAAU,cAEAO,EAAAE,KAAAnB,OAGA,QAAApE,GAAA,EAAAC,EAAAmE,EAAAnE,OAAgDD,EAAAC,EAAYD,KAE5DoE,EAAApE,GAAA6E,QACAE,IAAAX,EAAApE,GAAA+E,MACAD,GAAAV,EAAApE,GAAA8E,cAEAO,EAAAE,KAAAnB,EAAApE,GAeA,OANAqF,GAAApF,OACAjD,KAAAmI,QAAAS,GAAA,IAAAP,EAAApF,OAAAoF,EAAA,GAAAA,QAEArI,MAAAmI,QAAAS,GAGA5I,MASAgI,EAAArG,UAAAkI,mBAAA,SAAA1D,GACA,MAAAnG,MAAAmI,SAEAhC,QAAAnG,MAAAmI,QAAAD,IAAA/B,KACAnG,KAAAmI,QAAAD,KAAiCtG,OAAAC,OAAA,MAEjC7B,MALAA,MAWAgI,EAAArG,UAAAmI,IAAA9B,EAAArG,UAAA6H,eACAxB,EAAArG,UAAAoI,YAAA/B,EAAArG,UAAAgI,GAKA3B,EAAArG,UAAAqI,gBAAA,WACA,MAAAhK,OAMAgI,EAAAiC,SAAA/B,EAMArI,EAAAD,QAAAoI","file":"tasktimer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"TaskTimer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TaskTimer\"] = factory();\n\telse\n\t\troot[\"TaskTimer\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"TaskTimer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TaskTimer\"] = factory();\n\telse\n\t\troot[\"TaskTimer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _tasktimer = __webpack_require__(1);\n\t\n\tvar _tasktimer2 = _interopRequireDefault(_tasktimer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// export default re;\n\t// http://stackoverflow.com/a/33683495/112731\n\tmodule.exports = _tasktimer2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _eventemitter = __webpack_require__(2);\n\t\n\tvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar DEFAULT = {\n\t    INTERVAL: 1000\n\t};\n\t\n\t/**\n\t *  TaskTimer • https://github.com/onury/tasktimer\n\t *  @license MIT\n\t *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n\t */\n\t\n\t/**\n\t *  A timer utility for running periodic tasks on the given interval ticks.\n\t *  This is useful when you want to run or schedule multiple tasks on a single\n\t *  timer instance.\n\t *\n\t *  This class extends `EventEmitter3` which is an `EventEmitter` implementation\n\t *  for both Node and browser. Only a small set of its methods are documented in\n\t *  this documentation. For a complete list, refer to Node.js documentation.\n\t *\n\t *  @see `{@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}`\n\t */\n\t\n\tvar TaskTimer = function (_EventEmitter) {\n\t    _inherits(TaskTimer, _EventEmitter);\n\t\n\t    // ---------------------------\n\t    // CONSTRUCTOR\n\t    // ---------------------------\n\t\n\t    /**\n\t     * Constructs a new `TaskTimer` instance with the given time interval (in milliseconds).\n\t     * @constructor\n\t     *\n\t     * @param {Number} [interval=1000] - Timer interval in milliseconds.\n\t     * Since the tasks run on ticks instead of millisecond intervals; this value\n\t     * operates as the base resolution for all tasks. If you are running heavy\n\t     * tasks, lower interval requires higher CPU power. This value can be\n\t     * updated any time by setting the `interval` property on the instance.\n\t     * @returns {Object} - A new instance of `TaskTimer`.\n\t     *\n\t     * @example\n\t     * var timer = new TaskTimer(1000); // milliseconds\n\t     * // Execute some code on each tick...\n\t     * timer.on(\"tick\", function () {\n\t     *     console.log(\"tick count: \" + timer.tickCount);\n\t     *     console.log(\"elapsed time: \" + timer.time.elapsed + \" ms.\");\n\t     * });\n\t     * // Or add a task named \"heartbeat\" that runs every 5 ticks and a total of 10 times.\n\t     * var task = {\n\t     *     name: \"heartbeat\",\n\t     *     tickInterval: 5, // ticks\n\t     *     totalRuns: 10, // times\n\t     *     callback: function (task) {\n\t     *         console.log(task.name + \" task has run \" + task.currentRuns + \" times.\");\n\t     *     }\n\t     * };\n\t     * timer.addTask(task).start();\n\t     */\n\t    function TaskTimer() {\n\t        var interval = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT.INTERVAL : arguments[0];\n\t\n\t        _classCallCheck(this, TaskTimer);\n\t\n\t        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TaskTimer).call(this));\n\t\n\t        _this._ = {};\n\t        _this._reset();\n\t        _this._.interval = interval;\n\t        return _this;\n\t    }\n\t\n\t    // ---------------------------\n\t    // PUBLIC (INSTANCE) PROPERTIES\n\t    // ---------------------------\n\t\n\t    /**\n\t     * Gets or sets the interval of the timer, in milliseconds.\n\t     * Note that this will directly affect each task's execution times.\n\t     *\n\t     * @memberof TaskTimer\n\t     * @type {Number}\n\t     */\n\t\n\t\n\t    _createClass(TaskTimer, [{\n\t        key: '_stop',\n\t\n\t\n\t        // ---------------------------\n\t        // PRIVATE (INSTANCE) METHODS\n\t        // ---------------------------\n\t\n\t        /**\n\t         * Stops the timer.\n\t         * @private\n\t         */\n\t        value: function _stop() {\n\t            if (this._.timer) {\n\t                clearInterval(this._.timer);\n\t                this._.timer = null;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Resets the timer.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_reset',\n\t        value: function _reset() {\n\t            this._stop();\n\t            var interval = this._.interval;\n\t            this._ = {\n\t                interval: interval,\n\t                timer: null,\n\t                state: TaskTimer.State.IDLE,\n\t                tasks: {},\n\t                tickCount: 0,\n\t                startTime: 0,\n\t                stopTime: 0\n\t            };\n\t        }\n\t\n\t        /**\n\t         * Handler to be executed on each tick.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_tick',\n\t        value: function _tick() {\n\t            var name = void 0,\n\t                task = void 0,\n\t                tasks = this._.tasks;\n\t\n\t            this._.tickCount += 1;\n\t            this.emit(TaskTimer.Event.TICK);\n\t\n\t            for (name in this._.tasks) {\n\t                if (tasks[name]) {\n\t                    task = tasks[name];\n\t                    if (this._.tickCount % task.tickInterval === 0) {\n\t                        if (!task.totalRuns || task.currentRuns < task.totalRuns) {\n\t                            task.currentRuns += 1;\n\t                            if (typeof task.callback === 'function') {\n\t                                task.callback(task);\n\t                            }\n\t                            this.emit(TaskTimer.Event.TASK, task);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Runs the timer.\n\t         * @private\n\t         */\n\t\n\t    }, {\n\t        key: '_run',\n\t        value: function _run() {\n\t            var _this2 = this;\n\t\n\t            this._.timer = setInterval(function () {\n\t                // safe to use parent scope `this` in arrow functions.\n\t                _this2._tick();\n\t                _this2._.state = TaskTimer.State.RUNNING;\n\t            }, this._.interval);\n\t        }\n\t\n\t        // ---------------------------\n\t        // PUBLIC (INSTANCE) METHODS\n\t        // ---------------------------\n\t\n\t        /**\n\t         * Emits the given event with an optional event object.\n\t         * @memberof TaskTimer\n\t         * @alias TaskTimer#fire\n\t         * @chainable\n\t         *\n\t         * @param {String} eventName - The name of the event to be emitted.\n\t         * @param {Object} [object] - The event object that will be passed to the\n\t         * listener(s).\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'emit',\n\t        value: function emit(eventName, object) {\n\t            var event = {\n\t                type: eventName,\n\t                source: this\n\t            };\n\t            switch (eventName) {\n\t                case TaskTimer.Event.TASK:\n\t                case TaskTimer.Event.TASK_ADDED:\n\t                case TaskTimer.Event.TASK_REMOVED:\n\t                    event.task = object;\n\t                    break;\n\t                default:\n\t                    break;\n\t            }\n\t            _get(Object.getPrototypeOf(TaskTimer.prototype), 'emit', this).call(this, eventName, event);\n\t            return this;\n\t        }\n\t        /**\n\t         *  Alias for `#emit()`\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'fire',\n\t        value: function fire(eventName, object) {\n\t            return this.emit(eventName, object);\n\t        }\n\t\n\t        /**\n\t         * Gets the task with the given name.\n\t         * @memberof TaskTimer\n\t         *\n\t         * @param {String} name - Name of the task.\n\t         *\n\t         * @returns {Object} - Task.\n\t         */\n\t\n\t    }, {\n\t        key: 'getTask',\n\t        value: function getTask(name) {\n\t            return this._.tasks[name];\n\t        }\n\t\n\t        /**\n\t         * Adds a new task for the timer.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @todo options.autoRemove\n\t         *\n\t         * @param {Object|String} options - Task options. If a `String` is passed,\n\t         * a task with default options will be created with the given name.\n\t         *     @param {String} options.name - The unique name of the task.\n\t         *     @param {Number} [options.tickInterval=1] - Tick interval that the\n\t         *     task should be run on. The unit is \"ticks\" not milliseconds. For\n\t         *     instance, if the timer interval is 1000 milliseconds, and we add a\n\t         *     task with 5 tick intervals. The task will run on every 5 seconds.\n\t         *     @param {Number} [options.totalRuns=0] - Total number of times the\n\t         *     task should be run. `0` or `null` means unlimited (until the timer\n\t         *     has stopped).\n\t         *     @param {Function} [options.callback] - The callback function (task)\n\t         *     to be executed on each run. The task itself is passed to this\n\t         *     callback, as the single argument.\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         *\n\t         * @throws {Error} - If the task name is not set or a task with the given\n\t         * name already exists.\n\t         */\n\t\n\t    }, {\n\t        key: 'addTask',\n\t        value: function addTask() {\n\t            var options = arguments.length <= 0 || arguments[0] === undefined ? { tickInterval: 1, totalRuns: 0 } : arguments[0];\n\t\n\t            if (typeof options === 'string') {\n\t                options = {\n\t                    name: options,\n\t                    tickInterval: 1,\n\t                    totalRuns: 0\n\t                };\n\t            }\n\t            if (!options.name) {\n\t                throw new Error('Task name is required.');\n\t            }\n\t            if (this._.tasks[options.name]) {\n\t                throw new Error('Task with name \"' + options.name + '\" already exists.');\n\t            }\n\t            var task = _defaults(options, {\n\t                currentRuns: 0\n\t            });\n\t            this._.tasks[options.name] = task;\n\t            this.emit(TaskTimer.Event.TASK_ADDED, this.getTask(options.name));\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Resets the current runs of the task, by its given name; and re-runs the\n\t         * task on the next interval tick.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @param {String} name - The name of the task to be removed.\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         *\n\t         * @throws {Error} - If a task with the given name does not exist.\n\t         */\n\t\n\t    }, {\n\t        key: 'resetTask',\n\t        value: function resetTask(name) {\n\t            if (!name || !this._.tasks[name]) {\n\t                throw new Error('Task with name \"' + name + '\" does not exist.');\n\t            }\n\t            this._.tasks[name].currentRuns = 0;\n\t        }\n\t\n\t        /**\n\t         * Removes the task by the given name.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @param {String} name - The name of the task to be removed.\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         *\n\t         * @throws {Error} - If a task with the given name does not exist.\n\t         */\n\t\n\t    }, {\n\t        key: 'removeTask',\n\t        value: function removeTask(name) {\n\t            if (!name || !this._.tasks[name]) {\n\t                throw new Error('Task with name \"' + name + '\" does not exist.');\n\t            }\n\t            var removedTask = this._.tasks[name];\n\t            this._.tasks[name] = null;\n\t            delete this._.tasks[name];\n\t            this.emit(TaskTimer.Event.TASK_REMOVED, removedTask);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Starts the timer and puts the timer in `RUNNING` state. If it's already\n\t         * running, this will reset the start/stop time and tick count, but will not\n\t         * reset (or remove) existing tasks.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'start',\n\t        value: function start() {\n\t            this._stop();\n\t            this._.startTime = Date.now();\n\t            this._.stopTime = 0;\n\t            this._.tickCount = 0;\n\t            this._run();\n\t            this._.state = TaskTimer.State.RUNNING;\n\t            this.emit(TaskTimer.Event.STARTED);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Pauses the timer, puts the timer in `PAUSED` state and all tasks on hold.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'pause',\n\t        value: function pause() {\n\t            if (this.state !== TaskTimer.State.RUNNING) return this;\n\t            this._stop();\n\t            this._.state = TaskTimer.State.PAUSED;\n\t            this.emit(TaskTimer.Event.PAUSED);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Resumes the timer and puts the timer in `RUNNING` state; if previuosly\n\t         * paused. In this state, all existing tasks are resumed.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'resume',\n\t        value: function resume() {\n\t            if (this.state !== TaskTimer.State.PAUSED) return this;\n\t            this._run();\n\t            this._.state = TaskTimer.State.RUNNING;\n\t            this.emit(TaskTimer.Event.RESUMED);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Stops the timer and puts the timer in `STOPPED` state. In this state, all\n\t         * existing tasks are stopped and no values or tasks are reset until\n\t         * re-started or explicitly calling reset.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'stop',\n\t        value: function stop() {\n\t            if (this.state !== TaskTimer.State.RUNNING) return this;\n\t            this._stop();\n\t            this._.stopTime = Date.now();\n\t            this._.state = TaskTimer.State.STOPPED;\n\t            this.emit(TaskTimer.Event.STOPPED);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         * Stops the timer and puts the timer in `IDLE` state.\n\t         * This will reset the ticks and removes all tasks silently; meaning no\n\t         * other events will be emitted such as `\"taskRemoved\"`.\n\t         * @memberof TaskTimer\n\t         * @chainable\n\t         *\n\t         * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t         */\n\t\n\t    }, {\n\t        key: 'reset',\n\t        value: function reset() {\n\t            this._reset();\n\t            this.emit(TaskTimer.Event.RESET);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  `EventEmitter3` is said to be a drop-in replacement for Node's\n\t         *  `EventEmitter` but it lacks `listenerCount()` method.\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'listenerCount',\n\t        value: function listenerCount(eventName) {\n\t            return this.listeners(eventName).length;\n\t        }\n\t    }, {\n\t        key: 'interval',\n\t        get: function get() {\n\t            return this._.interval;\n\t        },\n\t        set: function set(value) {\n\t            this._.interval = value || DEFAULT.INTERVAL;\n\t        }\n\t\n\t        /**\n\t         * Gets the current state of the timer.\n\t         * For possible values, see `TaskTimer.State` enumeration.\n\t         *\n\t         * @memberof TaskTimer\n\t         * @type {Number}\n\t         * @readonly\n\t         */\n\t\n\t    }, {\n\t        key: 'state',\n\t        get: function get() {\n\t            return this._.state;\n\t        }\n\t\n\t        /**\n\t         * Gets time information about the latest run of the timer.\n\t         * `instance.time.started` gives the start time of the timer.\n\t         * `instance.time.stopped` gives the stop time of the timer. (`0` if still running.)\n\t         * `instance.time.elapsed` gives the elapsed time of the timer.\n\t         *\n\t         * @memberof TaskTimer\n\t         * @type {Object}\n\t         * @readonly\n\t         */\n\t\n\t    }, {\n\t        key: 'time',\n\t        get: function get() {\n\t            var current = this.state !== TaskTimer.State.STOPPED ? Date.now() : this._.stopTime;\n\t            return Object.freeze({\n\t                started: this._.startTime,\n\t                stopped: this._.stopTime,\n\t                elapsed: current - this._.startTime\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Gets the current tick count for the latest run of the timer.\n\t         * This value will be reset to `0` when the timer is stopped or reset.\n\t         *\n\t         * @memberof TaskTimer\n\t         * @type {Number}\n\t         * @readonly\n\t         */\n\t\n\t    }, {\n\t        key: 'tickCount',\n\t        get: function get() {\n\t            return this._.tickCount;\n\t        }\n\t\n\t        /**\n\t         * Gets the current task count. Tasks remain even after the timer is\n\t         * stopped. But they will be removed if the timer is reset.\n\t         *\n\t         * @memberof TaskTimer\n\t         * @type {Number}\n\t         * @readonly\n\t         */\n\t\n\t    }, {\n\t        key: 'taskCount',\n\t        get: function get() {\n\t            return Object.keys(this._.tasks).length;\n\t        }\n\t    }]);\n\t\n\t    return TaskTimer;\n\t}(_eventemitter2.default);\n\t\n\t// ---------------------------\n\t// PUBLIC (STATIC) PROPERTIES\n\t// ---------------------------\n\t\n\t/**\n\t * Enumerates the `TaskTimer` event types.\n\t * @enum {String}\n\t * @readonly\n\t */\n\t\n\t\n\tTaskTimer.Event = Object.freeze({\n\t    /**\n\t     * Emitted on each tick (interval) of `TaskTimer`.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    TICK: 'tick',\n\t    /**\n\t     * Emitted when the timer is put in `RUNNING` state; such as when the timer is\n\t     * started.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    STARTED: 'started',\n\t    /**\n\t     * Emitted when the timer is put in `RUNNING` state; such as when the timer is\n\t     * resumed.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    RESUMED: 'resumed',\n\t    /**\n\t     * Emitted when the timer is put in `PAUSED` state.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    PAUSED: 'paused',\n\t    /**\n\t     * Emitted when the timer is put in `STOPPED` state.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    STOPPED: 'stopped',\n\t    /**\n\t     * Emitted when the timer is reset.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    RESET: 'reset',\n\t    /**\n\t     * Emitted when a task is executed.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    TASK: 'task',\n\t    /**\n\t     * Emitted when a task is added to `TaskTimer` instance.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    TASK_ADDED: 'taskAdded',\n\t    /**\n\t     * Emitted when a task is removed from `TaskTimer` instance.\n\t     * Note that this will not be emitted when `.reset()` is called; which\n\t     * removes all tasks silently.\n\t     * @memberof TaskTimer.Event\n\t     * @type {String}\n\t     */\n\t    TASK_REMOVED: 'taskRemoved'\n\t});\n\t\n\t/**\n\t * Enumerates the `TaskTimer` states.\n\t * @enum {Number}\n\t * @readonly\n\t */\n\tTaskTimer.State = Object.freeze({\n\t    /**\n\t     * Indicates that the timer is in `IDLE` state.\n\t     * This is the initial state when the `TaskTimer` instance is first created.\n\t     * Also when an existing timer is reset, it will be `IDLE`.\n\t     * @memberof TaskTimer.State\n\t     * @type {Number}\n\t     */\n\t    IDLE: 0,\n\t    /**\n\t     * Indicates that the timer is in `RUNNING` state; such as when the timer is\n\t     * started or resumed.\n\t     * @memberof TaskTimer.State\n\t     * @type {Number}\n\t     */\n\t    RUNNING: 1,\n\t    /**\n\t     * Indicates that the timer is in `PAUSED` state.\n\t     * @memberof TaskTimer.State\n\t     * @type {Number}\n\t     */\n\t    PAUSED: 2,\n\t    /**\n\t     * Indicates that the timer is in `STOPPED` state.\n\t     * @memberof TaskTimer.State\n\t     * @type {Number}\n\t     */\n\t    STOPPED: 3\n\t});\n\t\n\t// ---------------------------\n\t// HELPER METHODS\n\t// ---------------------------\n\t\n\t// simple shallow defaults extender.\n\tfunction _defaults(object, defaults) {\n\t    if (!object) return defaults || {};\n\t    if (!defaults) return object || {};\n\t    var key;\n\t    for (key in defaults) {\n\t        if (defaults.hasOwnProperty(key) && object[key] === undefined) {\n\t            object[key] = defaults[key];\n\t        }\n\t    }\n\t    return object;\n\t}\n\t\n\t// ---------------------------\n\t// EXPORT\n\t// ---------------------------\n\t\n\texports.default = TaskTimer;\n\t\n\t// ---------------------------\n\t// ADDITIONAL DOCUMENTATION\n\t// ---------------------------\n\t\n\t/**\n\t *  Adds the listener function to the end of the listeners array for the event\n\t *  named `eventName`. No checks are made to see if the listener has already\n\t *  been added. Multiple calls passing the same combination of eventName and\n\t *  listener will result in the listener being added, and called, multiple times.\n\t *  @name TaskTimer#on\n\t *  @function\n\t *  @alias TaskTimer#addListener\n\t *  @chainable\n\t *\n\t *  @param {String} eventName - The name of the event to be added.\n\t *  @param {Function} listener - The callback function to be invoked per event.\n\t *\n\t *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t */\n\t\n\t/**\n\t *  Adds a one time listener function for the event named `eventName`. The next\n\t *  time eventName is triggered, this listener is removed and then invoked.\n\t *  @name TaskTimer#once\n\t *  @function\n\t *  @chainable\n\t *\n\t *  @param {String} eventName - The name of the event to be added.\n\t *  @param {Function} listener - The callback function to be invoked per event.\n\t *\n\t *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t */\n\t\n\t/**\n\t *  Removes the specified `listener` from the listener array for the event\n\t *  named `eventName`.\n\t *  @name TaskTimer#off\n\t *  @function\n\t *  @alias TaskTimer#removeListener\n\t *  @chainable\n\t *\n\t *  @param {String} eventName - The name of the event to be removed.\n\t *  @param {Function} listener - The callback function to be invoked per event.\n\t *\n\t *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t */\n\t\n\t/**\n\t *  Removes all listeners, or those of the specified eventName.\n\t *  @name TaskTimer#removeAllListeners\n\t *  @function\n\t *  @chainable\n\t *\n\t *  @param {String} eventName - The name of the event to be removed.\n\t *  @param {Function} listener - The callback function to be invoked per event.\n\t *\n\t *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n\t */\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t//\n\t// We store our EE objects in a plain object whose properties are event names.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// `~` to make sure that the built-in object properties are not overridden or\n\t// used as an attack vector.\n\t// We also assume that `Object.create(null)` is available when the event name\n\t// is an ES6 Symbol.\n\t//\n\tvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} [once=false] Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Hold the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  var events = this._events\n\t    , names = []\n\t    , name;\n\t\n\t  if (!events) return names;\n\t\n\t  for (name in events) {\n\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t  }\n\t\n\t  if (Object.getOwnPropertySymbols) {\n\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t  }\n\t\n\t  return names;\n\t};\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @param {Boolean} exists We only need to know if there are listeners.\n\t * @returns {Array|Boolean}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event, exists) {\n\t  var evt = prefix ? prefix + event : event\n\t    , available = this._events && this._events[evt];\n\t\n\t  if (exists) return !!available;\n\t  if (!available) return [];\n\t  if (available.fn) return [available.fn];\n\t\n\t  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = available[i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return false;\n\t\n\t  var listeners = this._events[evt]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} [context=this] The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this)\n\t    , evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;\n\t  else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);\n\t    else this._events[evt] = [\n\t      this._events[evt], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} [context=this] The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true)\n\t    , evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;\n\t  else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);\n\t    else this._events[evt] = [\n\t      this._events[evt], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Mixed} context Only remove listeners matching this context.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return this;\n\t\n\t  var listeners = this._events[evt]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn) {\n\t      if (\n\t           listeners.fn !== fn\n\t        || (once && !listeners.once)\n\t        || (context && listeners.context !== context)\n\t      ) {\n\t        events.push(listeners);\n\t      }\n\t    } else {\n\t      for (var i = 0, length = listeners.length; i < length; i++) {\n\t        if (\n\t             listeners[i].fn !== fn\n\t          || (once && !listeners[i].once)\n\t          || (context && listeners[i].context !== context)\n\t        ) {\n\t          events.push(listeners[i]);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[evt] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[evt];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[prefix ? prefix + event : event];\n\t  else this._events = prefix ? {} : Object.create(null);\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tif (true) {\n\t  module.exports = EventEmitter;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** tasktimer.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 00c84dd4c994f31aba94\n **/","import TaskTimer from './tasktimer';\n// export default re;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = TaskTimer;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import EventEmitter from 'eventemitter3';\n\nconst DEFAULT = {\n    INTERVAL: 1000\n};\n\n/**\n *  TaskTimer • https://github.com/onury/tasktimer\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\n\n/**\n *  A timer utility for running periodic tasks on the given interval ticks.\n *  This is useful when you want to run or schedule multiple tasks on a single\n *  timer instance.\n *\n *  This class extends `EventEmitter3` which is an `EventEmitter` implementation\n *  for both Node and browser. Only a small set of its methods are documented in\n *  this documentation. For a complete list, refer to Node.js documentation.\n *\n *  @see `{@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}`\n */\nclass TaskTimer extends EventEmitter {\n\n    // ---------------------------\n    // CONSTRUCTOR\n    // ---------------------------\n\n    /**\n     * Constructs a new `TaskTimer` instance with the given time interval (in milliseconds).\n     * @constructor\n     *\n     * @param {Number} [interval=1000] - Timer interval in milliseconds.\n     * Since the tasks run on ticks instead of millisecond intervals; this value\n     * operates as the base resolution for all tasks. If you are running heavy\n     * tasks, lower interval requires higher CPU power. This value can be\n     * updated any time by setting the `interval` property on the instance.\n     * @returns {Object} - A new instance of `TaskTimer`.\n     *\n     * @example\n     * var timer = new TaskTimer(1000); // milliseconds\n     * // Execute some code on each tick...\n     * timer.on(\"tick\", function () {\n     *     console.log(\"tick count: \" + timer.tickCount);\n     *     console.log(\"elapsed time: \" + timer.time.elapsed + \" ms.\");\n     * });\n     * // Or add a task named \"heartbeat\" that runs every 5 ticks and a total of 10 times.\n     * var task = {\n     *     name: \"heartbeat\",\n     *     tickInterval: 5, // ticks\n     *     totalRuns: 10, // times\n     *     callback: function (task) {\n     *         console.log(task.name + \" task has run \" + task.currentRuns + \" times.\");\n     *     }\n     * };\n     * timer.addTask(task).start();\n     */\n    constructor(interval = DEFAULT.INTERVAL) {\n        super();\n        this._ = {};\n        this._reset();\n        this._.interval = interval;\n    }\n\n    // ---------------------------\n    // PUBLIC (INSTANCE) PROPERTIES\n    // ---------------------------\n\n    /**\n     * Gets or sets the interval of the timer, in milliseconds.\n     * Note that this will directly affect each task's execution times.\n     *\n     * @memberof TaskTimer\n     * @type {Number}\n     */\n    get interval() {\n        return this._.interval;\n    }\n    set interval(value) {\n        this._.interval = value || DEFAULT.INTERVAL;\n    }\n\n    /**\n     * Gets the current state of the timer.\n     * For possible values, see `TaskTimer.State` enumeration.\n     *\n     * @memberof TaskTimer\n     * @type {Number}\n     * @readonly\n     */\n    get state() {\n        return this._.state;\n    }\n\n    /**\n     * Gets time information about the latest run of the timer.\n     * `instance.time.started` gives the start time of the timer.\n     * `instance.time.stopped` gives the stop time of the timer. (`0` if still running.)\n     * `instance.time.elapsed` gives the elapsed time of the timer.\n     *\n     * @memberof TaskTimer\n     * @type {Object}\n     * @readonly\n     */\n    get time() {\n        let current = this.state !== TaskTimer.State.STOPPED ? Date.now() : this._.stopTime;\n        return Object.freeze({\n            started: this._.startTime,\n            stopped: this._.stopTime,\n            elapsed: current - this._.startTime\n        });\n    }\n\n    /**\n     * Gets the current tick count for the latest run of the timer.\n     * This value will be reset to `0` when the timer is stopped or reset.\n     *\n     * @memberof TaskTimer\n     * @type {Number}\n     * @readonly\n     */\n    get tickCount() {\n        return this._.tickCount;\n    }\n\n    /**\n     * Gets the current task count. Tasks remain even after the timer is\n     * stopped. But they will be removed if the timer is reset.\n     *\n     * @memberof TaskTimer\n     * @type {Number}\n     * @readonly\n     */\n    get taskCount() {\n        return Object.keys(this._.tasks).length;\n    }\n\n    // ---------------------------\n    // PRIVATE (INSTANCE) METHODS\n    // ---------------------------\n\n    /**\n     * Stops the timer.\n     * @private\n     */\n    _stop() {\n        if (this._.timer) {\n            clearInterval(this._.timer);\n            this._.timer = null;\n        }\n    }\n\n    /**\n     * Resets the timer.\n     * @private\n     */\n    _reset() {\n        this._stop();\n        var interval = this._.interval;\n        this._ = {\n            interval: interval,\n            timer: null,\n            state: TaskTimer.State.IDLE,\n            tasks: {},\n            tickCount: 0,\n            startTime: 0,\n            stopTime: 0\n        };\n    }\n\n    /**\n     * Handler to be executed on each tick.\n     * @private\n     */\n    _tick() {\n        let name, task,\n            tasks = this._.tasks;\n\n        this._.tickCount += 1;\n        this.emit(TaskTimer.Event.TICK);\n\n        for (name in this._.tasks) {\n            if (tasks[name]) {\n                task = tasks[name];\n                if (this._.tickCount % task.tickInterval === 0) {\n                    if (!task.totalRuns || task.currentRuns < task.totalRuns) {\n                        task.currentRuns += 1;\n                        if (typeof task.callback === 'function') {\n                            task.callback(task);\n                        }\n                        this.emit(TaskTimer.Event.TASK, task);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Runs the timer.\n     * @private\n     */\n    _run() {\n        this._.timer = setInterval(() => {\n            // safe to use parent scope `this` in arrow functions.\n            this._tick();\n            this._.state = TaskTimer.State.RUNNING;\n        }, this._.interval);\n    }\n\n    // ---------------------------\n    // PUBLIC (INSTANCE) METHODS\n    // ---------------------------\n\n    /**\n     * Emits the given event with an optional event object.\n     * @memberof TaskTimer\n     * @alias TaskTimer#fire\n     * @chainable\n     *\n     * @param {String} eventName - The name of the event to be emitted.\n     * @param {Object} [object] - The event object that will be passed to the\n     * listener(s).\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     */\n    emit(eventName, object) {\n        var event = {\n            type: eventName,\n            source: this\n        };\n        switch (eventName) {\n            case TaskTimer.Event.TASK:\n            case TaskTimer.Event.TASK_ADDED:\n            case TaskTimer.Event.TASK_REMOVED:\n                event.task = object;\n                break;\n            default:\n                break;\n        }\n        super.emit(eventName, event);\n        return this;\n    }\n    /**\n     *  Alias for `#emit()`\n     *  @private\n     */\n    fire(eventName, object) {\n        return this.emit(eventName, object);\n    }\n\n    /**\n     * Gets the task with the given name.\n     * @memberof TaskTimer\n     *\n     * @param {String} name - Name of the task.\n     *\n     * @returns {Object} - Task.\n     */\n    getTask(name) {\n        return this._.tasks[name];\n    }\n\n    /**\n     * Adds a new task for the timer.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @todo options.autoRemove\n     *\n     * @param {Object|String} options - Task options. If a `String` is passed,\n     * a task with default options will be created with the given name.\n     *     @param {String} options.name - The unique name of the task.\n     *     @param {Number} [options.tickInterval=1] - Tick interval that the\n     *     task should be run on. The unit is \"ticks\" not milliseconds. For\n     *     instance, if the timer interval is 1000 milliseconds, and we add a\n     *     task with 5 tick intervals. The task will run on every 5 seconds.\n     *     @param {Number} [options.totalRuns=0] - Total number of times the\n     *     task should be run. `0` or `null` means unlimited (until the timer\n     *     has stopped).\n     *     @param {Function} [options.callback] - The callback function (task)\n     *     to be executed on each run. The task itself is passed to this\n     *     callback, as the single argument.\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     *\n     * @throws {Error} - If the task name is not set or a task with the given\n     * name already exists.\n     */\n    addTask(options = { tickInterval: 1, totalRuns: 0 }) {\n        if (typeof options === 'string') {\n            options = {\n                name: options,\n                tickInterval: 1,\n                totalRuns: 0\n            };\n        }\n        if (!options.name) {\n            throw new Error('Task name is required.');\n        }\n        if (this._.tasks[options.name]) {\n            throw new Error('Task with name \"' + options.name + '\" already exists.');\n        }\n        let task = _defaults(options, {\n            currentRuns: 0\n        });\n        this._.tasks[options.name] = task;\n        this.emit(TaskTimer.Event.TASK_ADDED, this.getTask(options.name));\n        return this;\n    }\n\n    /**\n     * Resets the current runs of the task, by its given name; and re-runs the\n     * task on the next interval tick.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @param {String} name - The name of the task to be removed.\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     *\n     * @throws {Error} - If a task with the given name does not exist.\n     */\n    resetTask(name) {\n        if (!name || !this._.tasks[name]) {\n            throw new Error('Task with name \"' + name + '\" does not exist.');\n        }\n        this._.tasks[name].currentRuns = 0;\n    }\n\n    /**\n     * Removes the task by the given name.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @param {String} name - The name of the task to be removed.\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     *\n     * @throws {Error} - If a task with the given name does not exist.\n     */\n    removeTask(name) {\n        if (!name || !this._.tasks[name]) {\n            throw new Error('Task with name \"' + name + '\" does not exist.');\n        }\n        var removedTask = this._.tasks[name];\n        this._.tasks[name] = null;\n        delete this._.tasks[name];\n        this.emit(TaskTimer.Event.TASK_REMOVED, removedTask);\n        return this;\n    }\n\n    /**\n     * Starts the timer and puts the timer in `RUNNING` state. If it's already\n     * running, this will reset the start/stop time and tick count, but will not\n     * reset (or remove) existing tasks.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     */\n    start() {\n        this._stop();\n        this._.startTime = Date.now();\n        this._.stopTime = 0;\n        this._.tickCount = 0;\n        this._run();\n        this._.state = TaskTimer.State.RUNNING;\n        this.emit(TaskTimer.Event.STARTED);\n        return this;\n    }\n\n    /**\n     * Pauses the timer, puts the timer in `PAUSED` state and all tasks on hold.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     */\n    pause() {\n        if (this.state !== TaskTimer.State.RUNNING) return this;\n        this._stop();\n        this._.state = TaskTimer.State.PAUSED;\n        this.emit(TaskTimer.Event.PAUSED);\n        return this;\n    }\n\n    /**\n     * Resumes the timer and puts the timer in `RUNNING` state; if previuosly\n     * paused. In this state, all existing tasks are resumed.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     */\n    resume() {\n        if (this.state !== TaskTimer.State.PAUSED) return this;\n        this._run();\n        this._.state = TaskTimer.State.RUNNING;\n        this.emit(TaskTimer.Event.RESUMED);\n        return this;\n    }\n\n    /**\n     * Stops the timer and puts the timer in `STOPPED` state. In this state, all\n     * existing tasks are stopped and no values or tasks are reset until\n     * re-started or explicitly calling reset.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     */\n    stop() {\n        if (this.state !== TaskTimer.State.RUNNING) return this;\n        this._stop();\n        this._.stopTime = Date.now();\n        this._.state = TaskTimer.State.STOPPED;\n        this.emit(TaskTimer.Event.STOPPED);\n        return this;\n    }\n\n    /**\n     * Stops the timer and puts the timer in `IDLE` state.\n     * This will reset the ticks and removes all tasks silently; meaning no\n     * other events will be emitted such as `\"taskRemoved\"`.\n     * @memberof TaskTimer\n     * @chainable\n     *\n     * @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n     */\n    reset() {\n        this._reset();\n        this.emit(TaskTimer.Event.RESET);\n        return this;\n    }\n\n    /**\n     *  `EventEmitter3` is said to be a drop-in replacement for Node's\n     *  `EventEmitter` but it lacks `listenerCount()` method.\n     *  @private\n     */\n    listenerCount(eventName) {\n        return this.listeners(eventName).length;\n    }\n\n}\n\n// ---------------------------\n// PUBLIC (STATIC) PROPERTIES\n// ---------------------------\n\n/**\n * Enumerates the `TaskTimer` event types.\n * @enum {String}\n * @readonly\n */\nTaskTimer.Event = Object.freeze({\n    /**\n     * Emitted on each tick (interval) of `TaskTimer`.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    TICK: 'tick',\n    /**\n     * Emitted when the timer is put in `RUNNING` state; such as when the timer is\n     * started.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    STARTED: 'started',\n    /**\n     * Emitted when the timer is put in `RUNNING` state; such as when the timer is\n     * resumed.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    RESUMED: 'resumed',\n    /**\n     * Emitted when the timer is put in `PAUSED` state.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    PAUSED: 'paused',\n    /**\n     * Emitted when the timer is put in `STOPPED` state.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    STOPPED: 'stopped',\n    /**\n     * Emitted when the timer is reset.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    RESET: 'reset',\n    /**\n     * Emitted when a task is executed.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    TASK: 'task',\n    /**\n     * Emitted when a task is added to `TaskTimer` instance.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    TASK_ADDED: 'taskAdded',\n    /**\n     * Emitted when a task is removed from `TaskTimer` instance.\n     * Note that this will not be emitted when `.reset()` is called; which\n     * removes all tasks silently.\n     * @memberof TaskTimer.Event\n     * @type {String}\n     */\n    TASK_REMOVED: 'taskRemoved'\n});\n\n/**\n * Enumerates the `TaskTimer` states.\n * @enum {Number}\n * @readonly\n */\nTaskTimer.State = Object.freeze({\n    /**\n     * Indicates that the timer is in `IDLE` state.\n     * This is the initial state when the `TaskTimer` instance is first created.\n     * Also when an existing timer is reset, it will be `IDLE`.\n     * @memberof TaskTimer.State\n     * @type {Number}\n     */\n    IDLE: 0,\n    /**\n     * Indicates that the timer is in `RUNNING` state; such as when the timer is\n     * started or resumed.\n     * @memberof TaskTimer.State\n     * @type {Number}\n     */\n    RUNNING: 1,\n    /**\n     * Indicates that the timer is in `PAUSED` state.\n     * @memberof TaskTimer.State\n     * @type {Number}\n     */\n    PAUSED: 2,\n    /**\n     * Indicates that the timer is in `STOPPED` state.\n     * @memberof TaskTimer.State\n     * @type {Number}\n     */\n    STOPPED: 3\n});\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n// simple shallow defaults extender.\nfunction _defaults(object, defaults) {\n    if (!object) return defaults || {};\n    if (!defaults) return object || {};\n    var key;\n    for (key in defaults) {\n        if (defaults.hasOwnProperty(key)\n                && object[key] === undefined) {\n            object[key] = defaults[key];\n        }\n    }\n    return object;\n}\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default TaskTimer;\n\n// ---------------------------\n// ADDITIONAL DOCUMENTATION\n// ---------------------------\n\n/**\n *  Adds the listener function to the end of the listeners array for the event\n *  named `eventName`. No checks are made to see if the listener has already\n *  been added. Multiple calls passing the same combination of eventName and\n *  listener will result in the listener being added, and called, multiple times.\n *  @name TaskTimer#on\n *  @function\n *  @alias TaskTimer#addListener\n *  @chainable\n *\n *  @param {String} eventName - The name of the event to be added.\n *  @param {Function} listener - The callback function to be invoked per event.\n *\n *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n */\n\n/**\n *  Adds a one time listener function for the event named `eventName`. The next\n *  time eventName is triggered, this listener is removed and then invoked.\n *  @name TaskTimer#once\n *  @function\n *  @chainable\n *\n *  @param {String} eventName - The name of the event to be added.\n *  @param {Function} listener - The callback function to be invoked per event.\n *\n *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n */\n\n /**\n  *  Removes the specified `listener` from the listener array for the event\n  *  named `eventName`.\n  *  @name TaskTimer#off\n  *  @function\n  *  @alias TaskTimer#removeListener\n  *  @chainable\n  *\n  *  @param {String} eventName - The name of the event to be removed.\n  *  @param {Function} listener - The callback function to be invoked per event.\n  *\n  *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n  */\n\n /**\n  *  Removes all listeners, or those of the specified eventName.\n  *  @name TaskTimer#removeAllListeners\n  *  @function\n  *  @chainable\n  *\n  *  @param {String} eventName - The name of the event to be removed.\n  *  @param {Function} listener - The callback function to be invoked per event.\n  *\n  *  @returns {Object} - `{@link #TaskTimer|TaskTimer}` instance.\n  */\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/tasktimer.js\n **/","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter3/index.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}